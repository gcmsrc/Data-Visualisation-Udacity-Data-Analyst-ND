<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>DAND - Data Viz</title>
	<script src="https://d3js.org/d3.v3.min.js"></script>
	<script src="https://d3js.org/colorbrewer.v1.min.js"></script>
	<!-- https://github.com/d3/d3-scale-chromatic -->
	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
	<script type="text/javascript" src='support.js'></script>
	<script type="text/javascript" src='trends.js'></script>
	<script type="text/javascript" src='map.js'></script>
	<link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,300i,400,400i,700" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="newstyle.css">
</head>
<body>
	
	<!--Tooltip as per Scott Murray-->
	<div id="tooltip" class='hidden focus-bar map'>
		<p><span id='tooltip-title'></span></p>
		<p><span id='tooltip-value'></span></p>
	</div>

	<script type="text/javascript">

    	//----------------------------------------------------------//

		// *** CHART AND DRAWING AREA ***
		// Add chart
		var chart = d3.select("body")
					  .append("svg")
					  .attr("width", outerWidth)
					  .attr("height", outerHeight)
					  .append('g');


		// TEST: Append chart buttons
		var buttons = ['visits', 'purpose', 'origin'];
		chart.selectAll('text')
			 .data(buttons)
			 .enter()
			 .append('text')
			 .attr('class', 'button')
			 .attr('x', function(d, i) {
			 	return 0.7 * innerWidth + i * 60;
			 })
			 .attr('y', 1.2 * padding.top)
			 .attr('id', function(d) {return d;})
			 .text(function(d) {
			 	return d;
			 });

		// Add drawing area
	    var area = chart.append('g')
	    		        .attr('class', 'area');
		// Append title
		chart.append('g')
		     .attr('id', 'title')
		     .attr('transform', 'translate(' + (3 * padding.left) + ',' + (1.3 * padding.top) + ')')
		     .append('text')
		     .style("text-anchor", "start");

		// Add click behaviour to buttons
		d3.select('#visits')
		  .on('click', function() {
		  	trends(1)
		  });
		d3.select('#purpose')
		  .on('click', function() {
		  	trends(2)
		  });

		d3.select('#origin')
		  .on('click', function() {
		  	map();
		  })

		// This function draws charts for points 3 and 4
		/*var map = function() {

			// Remove elements in area
			remove_object('*', all=true)
			
			// Define color function
			var color = d3.scale.linear()
					  	  .range([0,1]);

			// Change title
			changeTitle('International Visitors to London by Country of Origin');

			// File downloaded from natural earth data as per Scott Murray
			// File was simplified with mapshaper
			// coropleth chapter from Scott Murray
			d3.csv('dataset_geo.csv', parseMap, function(data) {
				
				// Extract years
				var years = d3.set();

				data.forEach(function(d) {
					years.add(d.year)
				})

				var years = years.values();

				// Nesting by market, i.e. by country of origin
				// https://github.com/d3/d3-collection#nests
				var nested = d3.nest()
							   .key(function(d) {
							   		return d.market;
							   })
							   .entries(data)

				// Update color domain
				color.domain([0,
					roundUpThousand(d3.max(nested, function(d) {
						return d3.max(d.values, function(x) {
							return +x.visits;
						});
					}))]);
				
				// Transform nested from array of objects to object
				nested.forEach(function(x) {
					
					// Empty object
					var rv = {};

					x.values.forEach(function(d, i) {
						rv[d.year] = {
							visits: d.visits,
							spend: d.spend,
							rel_spend: d.spend / d.visit
						}
					});

					// Replace array with object
					x.values = rv;
				})

				// Load json data (map)
				d3.json('coord_names_only.json', function(json) {

					// Enrich map with nested data
					for (var i = 0; i < nested.length; i++) {

						var dataCountry = nested[i].key;
						var dataValues = nested[i].values;
						
						for (var j = 0; j < json.features.length; j++) {
							
							var jsonCountry = json.features[j].properties.name;

							if (dataCountry == jsonCountry) {

								json.features[j].properties.visitors = dataValues;
								break;
							}
						}
					}

					// *** Bind data ***
					var countries = area.selectAll('path')
										.data(json.features)
										.enter()
										.append('path')
										.attr('d', path)
										.attr('class', 'map country')
										.style('stroke', 'white')
										.style('stroke-width', 0.75)
										.style('fill', 'white');
					
					// Append year box
					var year_box = area.append('text')
									   .attr('x', 4 * padding.right)
									   .attr('y', 0.88 * outerHeight)
									   .attr('class', 'year map')
									   .style('opacity', 0)

					// *** TEST ***
					// *************************
					var focus = area.append('g')
								    .attr('id', 'focus')
								    .attr('class', 'hidden map')
								    .attr('transform', 'translate(' + 4 * padding.right + ',' + 0.63 * outerHeight + ')')

					var yearAxis = d3.svg.axis()
									 .orient('bottom')
									 .innerTickSize(0)
									 .tickValues([2002, 2015])
									 .tickPadding(5)

					focus.append('g')
    		   			 .attr('class', 'axis focus-x');
					
					var xScale = d3.scale.ordinal()
					   .rangeRoundBands([5, 130], 0.05)
					   .domain(years)

					yearAxis.scale(xScale);
					area.select('.focus-x')
			    		.call(yearAxis);


					focus.append('g')
	 					 .attr('class', 'axis focus-y');

			    	var yScale = d3.scale.linear()
			    				   .range([-30,0]);

			    	var valueAxis = d3.svg.axis()
									  .orient('left')
									  .ticks(0);

			    	var countryData = function(state) {
			    		return area.selectAll('.country')
			    		           .filter(function(d) {
			    		           		return d.properties['name'] == state;
			    		           	}).data()[0].properties.visitors;
			    	};*/


			    	// *************************
					// *** END TEST ***

					// Define update function
					/*var update_map = function(year) {

						// Update fill
						countries.transition()
								 .duration(50)
								 .style('stroke', '#beb7b7')
								 .style('fill', function(d) {

								 	// Check if visitors and year data is available
								 	if(d.properties.visitors) {
								 		if(d.properties.visitors[year]) {
								 			var dataColor = color(+d.properties.visitors[year].visits);
								 			return d3.interpolateBlues(dataColor);
								 		} else {
								 			return 'white'
								 		}
								 	} else {
								 		return 'white'
								 	}					   	
								 })

						// Update year box
						year_box.transition()
								.duration(50)
								.text(year)
								.style('opacity', 1);

						// Update tootltip value
						d3.select('#tooltip-value')
						  .text(function() {
						  	if (this.textContent != '') {

						  		var state = d3.select('#tooltip-title').node().textContent;
						  	
						  		var stateData = countryData(state);
						  		
						  		if (stateData[year]) {
						  			d3.select(this)
						  			  .transition()
						  			  .duration(500)
						  			  .text(formatMap(stateData[year].visits))
						  		} else {
						  			d3.select(this)
						  			  .transition()
						  			  .duration(500)
						  			  .text('N/A');
						  		}

						  	}
						 });
						 
						 // Update circle (if any)
						 if(focus.select('circle')[0][0]) {
						 	focus.select('circle')
						 		 .transition()
						 		 .duration(50)
						 		 .attr('cx', xScale(year) + xScale.rangeBand()/2)
						 		 .attr('cy', function() {
						 		 	
						 		 	var state = d3.select('#tooltip-title').node().textContent;
						 		 	var stateData = countryData(state)

						 		 	if(stateData[year]){
						 		 		return yScale(+stateData[year].visits);
						 		 	}
						 		 	

						 		 })
						 		 .style('fill', function() {
						 		 	var state = d3.select('#tooltip-title').node().textContent;
						 		 	var stateData = countryData(state)

						 		 	if(!stateData[year]) {
						 		 		return 'white';
						 		 	} else {
						 		 		return 'red';
						 		 	}

						 		 	
						 		 })
						 }

						// Behaviour of clicking on map
						//debugger;

						// Update mouseover behaviour
						countries.on('mouseover', function(d) {

									// Check if visitors and year data is available
									if (d.properties.visitors) {
										if (d.properties.visitors[year]) {
											// Change the cursor
											d3.select(this)
											.style('cursor', 'pointer');
										}
									}
							      })
								  .on('click', function(d) {

								  	var previous = null;
								  	
								  	if (d3.select('#tooltip-title')[0][0].textContent != '') {
								  		previous = d3.select('#tooltip-title')[0][0].textContent;
								  	}
	  								
	  								var current = d.properties.name;
								  	// Check if selected
								  	
								  	var active = this.active? true:false;
								  	console.log(previous, current, active)
									
									// Check if visitors and year data is available
									if (d.properties.visitors) {

										if (d.properties.visitors[year]) {
											
											// Change tooltip
											d3.select("#tooltip")
											.style("left", (4 * padding.right) + "px")
											.style("top", (0.68 * outerHeight) + 'px')
											.style("width", '200px')
											.classed('map', true)
											.classed('trend', false)

											// Add tooltip content
											d3.select('#tooltip-title')
											.text(current);

											d3.select("#tooltip-value")
											.text(formatMap(d.properties.visitors[year].visits));

											// Make tooltip visible
											//http://bl.ocks.org/d3noob/5d621a60e2d1d02086bf

											// TESTING
											var state = d.properties.name;
											var stateData = countryData(state);

											var test = Object.keys(stateData)
											     			 .map(function(key) {
											     			 	return {
											     			 		'x':key,
											     			 		'y':stateData[key].visits
											     			 	}
											     			 })
											yScale.domain([
												d3.max(test, function(d) {
													return +d.y;
												}),
												d3.min(test, function(d) {
													return +d.y;
												})]);

											valueAxis.scale(yScale);
											focus.select('.focus-y')
			    								.call(valueAxis);

											var testLine = d3.svg.line()
							     							.x(function(d) { return xScale(d.x) + xScale.rangeBand() / 2; })
							     							.y(function(d) { return yScale(+d.y); });
						     			

							     			if (previous!=current) {
							     				
							     				focus.select('.focus-line')
							     					 .remove();

							     				focus.select('.focus-circle')
							     					 .remove();

							     				focus.append('path')
							     			     .attr('d', testLine(test))
							     			     .attr('class', 'focus-line')

							     			    focus.append('circle')
							     			    	 .attr('r', 4)
							     			    	 .attr('class', 'focus-circle')
							     			    	 .attr('cx', function() {
							     			    	 	return xScale(year) + xScale.rangeBand() / 2;
							     			    	 })
							     			    	 .attr('cy', function() {
							     			    	 	return yScale(stateData[year].visits)
							     			    	 })
							     			    	 .style('fill', 'red')
							     			    	 .style('stroke', 'white')
							     			    	 .style('stroke-width', 2)

							     			    d3.select('#focus')
												  	.classed('hidden', false);

												d3.select('#tooltip')
												  .classed('hidden', false);

							     			} else {
							     				
							     				focus.select('.focus-line')
							     					 .remove();

							     				focus.select('.focus-circle')
							     					 .remove();

							     				d3.select('#focus')
												  	.classed('hidden', true);

												d3.select('#tooltip')
												  .classed('hidden', true);

												d3.select('#tooltip-title')
												  .text('');					     				
							     			}

											// END TESTING
											this.active = !active;	

										} /*else  {
											
											if (d3.select('#tooltip-title').textContent != '') {
												
												d3.select('#tooltip')
													  .classed('hidden', active);

												d3.select('#focus')
												  .classed('hidden', active);
											}
										}*/
							/*		}
								  });
					};

					var year = '2015'			
					update_map(year);

					year_box.on('mouseover', function() {

						// Change cursor
						d3.select(this)
						  .style('cursor', 'ew-resize');

						var box = year_box.node().getBBox();

						var yearScale = d3.scale.linear()
										  .domain([2002, 2015])
										  .range([box.x + 5 , box.x + box.width - 5]);

						year_box.on('mousemove', function() {

							// Cancel current transition if any
							area.transition().duration(0);

							var value = Math.round(yearScale.invert(d3.mouse(this)[0]));

							if(value < 2002) {
								return 2002;
							} else if (value > 2015) {
								return 2015
							}

							year_box.transition()
									.duration(150)
									.text(value);
	
							update_map(value.toString());
						})

					})

					// Add legend
					//http://bl.ocks.org/lucguillemot/37cc6eccbdd365556feb
					var legend = area.append('g')
									 .attr('class', 'map legend')
									 .attr('transform', 'translate(' + (4 * padding.right) + ',' + (0.88 * outerHeight) + ')')

					var newData = [];
					var legend_width = 150;
					var divisions = 100;
				    var sectionWidth = Math.floor(legend_width / divisions);

				    for (var i=0; i < legend_width; i+= sectionWidth ) {
				        newData.push(i);
				    };

				    var legend_scale = d3.scale.linear()
				    					 .domain([0, newData.length - 1])
				    					 .range([0, 1]);

				    legend.selectAll('rect')
				        .data(newData)
				        .enter()
				        .append('rect')
				            .attr("x", function(d) { return d; })
				            .attr("y", 10)
				            .attr("height", 10)
				            .attr("width", sectionWidth)
				            .attr('fill', function(d, i) {
				            	var dataColor = legend_scale(i);
				            	return d3.interpolateBlues(dataColor);
				            });

				    legend.append("text")
				    	  .attr('class', 'legend-range')
				    	  .text(0)
				    	  .attr("transform","translate(" + 2.5 +',' + 35 + ')')

				    legend.append("text")
				    	  .attr('class', 'legend-range')
				    	  .text(formatMap(color.domain()[1]))
				    	  .attr("transform","translate(" + 127.5 + ',' + 35 + ')')
				})
			

				


			})
		};*/

		

		/*d3.select('#origin')
		  .on('click', function() {
		  	map();
		  });*/

	</script>
</body>
</html>